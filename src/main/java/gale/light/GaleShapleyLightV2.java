package gale.light;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;
import java.util.stream.IntStream;

/**
 * Implementation of the Gale Shapley Algorithm for creating stable matches. It matches Proposers with Proposed. Only
 * Hetero-Matches are allowed. No Proposer can match with another Proposer, same rule for the Proposed. A pair is always
 * made up of 1 Proposer and 1 Proposed, no groups of more than 2 are allowed
 */
public class GaleShapleyLightV2 {

    /**
     * The group size of the Proposers and Proposed. The groups need to have the same size. In total there will be
     * 2 * groupSize entities for the Algorithm
     */
    public int groupSize;

    /**
     * Static method for generating a random preferences 2d-Array with a given Group Size. The Array is valid to be used
     * with the Gale Shapley Algorithm Implementation of this class. It has a size of int[groupSize*2][groupSize]. This
     * means it has (groupSize*2) * (groupSize) entities in it
     * @param groupSize integer value representing the size of the groups
     * @return Valid int[groupSize*2][groupSize] Array for the usage in the Gale Shapley Algorithm
     */
    public static int[][] generateRandomData(int groupSize) {

        if (groupSize < 1){
            throw new IllegalStateException("Group size cannot be negative");
        }
        int[] men = IntStream.range(0, groupSize).toArray();
        int[] women = IntStream.range(groupSize, 2*groupSize).toArray();
        int[][] preferences = new int[groupSize*2][groupSize];
        for (int row = 0; row < preferences.length; row++) {
            shuffleArray(men);
            shuffleArray(women);
            for (int col = 0; col < preferences[row].length; col++) {

                if (row < groupSize)
                    preferences[row][col] = women[col];
                else
                    preferences[row][col] = men[col];
            }
        }
        return preferences;
    }

    /**
     * Helper method for the generateRandomData(int groupSize) Method. It shuffles an array with the java.util.random
     * package from Java
     * @param array Input Array that will be shuffled
     */
    private static void shuffleArray(int[] array) {

        Random rand = new Random();
        for (int i = 0; i < array.length; i++) {
            int randomIndexToSwap = rand.nextInt(array.length);
            int temp = array[randomIndexToSwap];
            array[randomIndexToSwap] = array[i];
            array[i] = temp;
        }
    }

    /**
     * The old Version of the Gale Shapley Algorithm class (V1) had another type of 1d-preferences array for the proposed
     * Group. This function converts the old type of preferences (for a single Proposed) array to the new type of the V2 class
     * @param preferences Input array representing the preferences of a sinlge Proposed from the GaleShapleyLightV1 class
     * @return Array representing a preference array from a Proposed entity for the GaleShapleyV2 Class
     */
    public static int[] convertV1PreferenceToV2(int[] preferences) {

        int groupSize = preferences.length;
        int[] tmp = new int[groupSize];
        for (int i = 0; i < groupSize; i++){
            int man = preferences[i];
            tmp[man] = i;
        }
        return tmp;
    }

    /**
     * The old Version of the Gale Shapley Algorithm class (V1) had another type of 1d-preferences array for the proposed
     * Group. This function converts the old type of preferences (for the whole group) array to the new type of the V2 class
     * @param preferences preferences 2d-Array representing the preferences of the Proposer and Proposed Entities. Here
     * all preferences are structured the same. First entities in the arrays are of higher preference
     */
    public static void convertV1PreferenceToV2(int[][] preferences) {

        int groupSize = preferences[0].length;
        for (int i = groupSize; i < (groupSize*2); i++){
            int[] tmp = GaleShapleyLightV2.convertV1PreferenceToV2(preferences[i]);
            preferences[i] = tmp;
        }
    }

    /**
     * Method that prints the stable matches made by the Gale Shapley Algorithm
     * @param proposedPartners Array representing the stable matches generated by the Gale Shapley Algorithm
     */
    public static void printMatches(int[] proposedPartners) {

        System.out.println("proposed\t\tproposer");
        for (int i = 0; i < proposedPartners.length; i++) {
            System.out.print("");
            System.out.println(i + proposedPartners.length + "\t\t\t\t" +
                    proposedPartners[i]);
        }
    }

    /**
     * Constructor for the GaleShapleyV2 Class
     * @param groupSize Size of the individual Proposer and Proposed groups
     */
    public GaleShapleyLightV2(int groupSize) {
        this.groupSize = groupSize;
    }

    /**
     * Implementation of the Gale Shapley Algorithm for creating stable Matches with 2 equally sized groups. In the worst
     * case it runs in O(n-squared) and theoretically in n(n−1)+1 computations. This function has no debugging output,
     * and it only checks for a small amount of user input error
     * @param preferences 2d-Array representing the preferences of the Proposer and Proposed Entities. It should have the size of int[groupSize*2][groupSize].
     * Proposers are numbered as 0 to groupSize-1 and Proposed are numbered as groupSize to 2*groupSize-1. The ordering
     * of the Proposed and Proposer Group in the preferences array is different. Proposers have their most preferable
     * match in the front of the array and their least preferable match in the back. Proposed have their preferences in
     * an Array where they can get the preference of a specific proposer in O(1) time complexity. Meaning that if they
     * want their preference of Proposer number 3 they can access it by getting the index 3 of their preferences array.
     * The highest rank is 0 and the lowest is groupSize-1
     * @return Array representing the stable matches generated by the Gale Shapley Algorithm. Array[i] is the partner assigned to proposed groupSite+i
     */
    public int[] findCouples(int[][] preferences) {

        if (preferences.length != this.groupSize*2 || preferences[0].length != this.groupSize){
            throw new IllegalStateException("Group size does not match preference array size");
        }
        Queue<Integer> proposerQueue = new LinkedList<>();
        for (int i = 0; i < groupSize; i++) {
            proposerQueue.add(i);
        }
        int[] proposedPartners = new int[groupSize];
        Arrays.fill(proposedPartners, -1);
        int[] proposerState = new int[groupSize];
        Arrays.fill(proposerState, -1);
        while (!proposerQueue.isEmpty()) {
            int proposer = proposerQueue.poll();
            for (int i = proposerState[proposer]+1; i < groupSize; i++) {
                int proposed = preferences[proposer][i];
                if (proposedPartners[proposed - groupSize] == -1) {
                    proposedPartners[proposed - groupSize] = proposer;
                    proposerState[proposer] = i;
                    break;
                }
                else {
                    int currentMatch = proposedPartners[proposed - groupSize];
                    if (proposedPrefersProposerOverMatch(preferences, proposed, proposer, currentMatch)) {
                        proposedPartners[proposed - groupSize] = proposer;
                        proposerQueue.add(currentMatch);
                        proposerState[proposer] = i;
                        break;
                    }
                }
            }
        }
        return proposedPartners;
    }

    /**
     * Implementation of the Gale Shapley Algorithm for creating stable Matches with 2 equally sized groups. In the worst
     * case it runs in O(n-squared) and theoretically in n(n−1)+1 computations. This function has debugging output by
     * printing it to the console. It only checks for a small amount of user input error
     * @param preferences 2d-Array representing the preferences of the Proposer and Proposed Entities. It should have the size of int[groupSize*2][groupSize].
     * Proposers are numbered as 0 to groupSize-1 and Proposed are numbered as groupSize to 2*groupSize-1. The ordering
     * of the Proposed and Proposer Group in the preferences array is different. Proposers have their most preferable
     * match in the front of the array and their least preferable match in the back. Proposed have their preferences in
     * an Array where they can get the preference of a specific proposer in O(1) time complexity. Meaning that if they
     * want their preference of Proposer number 3 they can access it by getting the index 3 of their preferences array.
     * The highest rank is 0 and the lowest is groupSize-1
     * @return Array representing the stable matches generated by the Gale Shapley Algorithm. Array[i] is the partner assigned to proposed groupSite+i
     */
    public int[] findCouplesPrint(int[][] preferences) {

        if (preferences.length != this.groupSize*2 || preferences[0].length != this.groupSize){
            throw new IllegalStateException("Group size does not match preference array size");
        }
        //Queue of proposers and filling it with 0 to N-1 (number of proposers)
        Queue<Integer> proposerQueue = new LinkedList<>();
        for (int i = 0; i < groupSize; i++) {
            proposerQueue.add(i);
        }
        //Stores partners of the proposed. The value of proposedPartners[i] is the partner
        //assigned to proposed N+i. The value -1 indicates that the entity is unmatched
        //Initialize all proposers and proposed as unmatched (-1)
        int[] proposedPartners = new int[groupSize];
        Arrays.fill(proposedPartners, -1);
        //Tracks what proposed the proposer already proposed to.
        int[] proposerState = new int[groupSize];
        Arrays.fill(proposerState, -1);
        //While there are free proposers in the queue
        while (!proposerQueue.isEmpty()) {
            //Pick the first free proposer (we could pick any)
            int proposer = proposerQueue.poll();
            //Go through the preferences of the current proposer in order
            for (int i = proposerState[proposer]+1; i < groupSize; i++) {
                int proposed = preferences[proposer][i];
                System.out.println(proposer + " Is proposing to " + proposed);
                //Proposed is unmatched, we match them
                if (proposedPartners[proposed - groupSize] == -1) {
                    proposedPartners[proposed - groupSize] = proposer;
                    proposerState[proposer] = i;
                    break;
                }
                //Proposed is already matched, we have to check if new match is preferred
                else {
                    int currentMatch = proposedPartners[proposed - groupSize];
                    System.out.println("\t\tProposed: " + proposed + " already matched to: " + currentMatch);
                    //If proposed prefers proposer over currentMatch, rematch them
                    if (proposedPrefersProposerOverMatch(preferences, proposed, proposer, currentMatch)) {
                        System.out.println("\t\tProposed prefers new match");
                        proposedPartners[proposed - groupSize] = proposer;
                        proposerQueue.add(currentMatch);
                        proposerState[proposer] = i;
                        break;
                    }
                }
            }
        }
        return proposedPartners;
    }

    /**
     * Method that checks if a Proposed entity prefers the given Proposer over its current match. Runs in worst case O(1)
     * @param preferences 2d-Array representing the preferences of the Proposer and Proposed Entities
     * @param proposed Proposed that maybe wants to switch its match
     * @param proposer Proposer that asks the Proposed to switch
     * @param currentMatch Current match of the Proposed
     * @return true if the Proposed entity wants to switch and false if it does not want to
     */
    public boolean proposedPrefersProposerOverMatch(int[][] preferences, int proposed, int proposer, int currentMatch) {
        return preferences[proposed][proposer] < preferences[proposed][currentMatch];
    }

    /**
     * Method that checks if a Proposer entity prefers the given Proposed over its current match. Runs in worst case O(N).
     * Throws an error if the Proposed entity is not existing in the preferences array of the Proposer. This cannot happen
     * if the preferences array is valid
     * @param preferences 2d-Array representing the preferences of the Proposer and Proposed Entities
     * @param proposed Proposed that asks the Proposer to switch
     * @param proposer Proposer that maybe wants to switch its match
     * @param currentMatch Current match of the Proposer
     * @return true if the Proposer entity wants to switch and false if it does not want to
     */
    public boolean proposerPrefersProposedOverMatch(int[][] preferences, int proposed, int proposer, int currentMatch) {

        for (int i = 0; i < this.groupSize; i++){
            if (preferences[proposer][i] == currentMatch){
                return false;
            }
            if (preferences[proposer][i] == proposed){
                return true;
            }
        }
        throw new RuntimeException("No possible proposed found");
    }

    /**
     * Method that checks all the matches generated by the Gale Shapley Algorithm for their Stability
     * @param preferences 2d-Array representing the preferences of the Proposer and Proposed Entities
     * @param proposedPartners Array representing the stable matches generated by the Gale Shapley Algorithm
     * @return true if all matches are stable and false if at least one match is unstable
     */
    public boolean allMatchesStable(int[][] preferences, int[] proposedPartners) {

        //Iterating over pairings
        for(int i = 0; i < this.groupSize; i++){
            int proposed = i + this.groupSize;
            //Iterating over preferences of proposed and checking if proposed prefers any other proposers
            for (int j = 0; j < this.groupSize; j++){
                int proposer = preferences[i + groupSize][j];
                if (this.proposedPrefersProposerOverMatch(preferences, proposed, proposer, proposedPartners[i])){
                    //Check if that proposer also prefers the proposed over current match
                    if (this.proposerPrefersProposedOverMatch(preferences, proposed, proposer,
                            this.getProposersMatch(proposer, proposedPartners))){
                        return false;
                    }
                }
            }
        }
        return true;
    }

    /**
     * Helper Method for finding the match of a Proposer entity
     * @param proposer Proposer
     * @param proposedPartners Array representing the stable matches generated by the Gale Shapley Algorithm
     * @return int representing the Proposer entities match
     */
    public int getProposersMatch(int proposer, int[] proposedPartners) {

        for (int i = 0; i < this.groupSize; i++){
            if (proposedPartners[i] == proposer){
                return i + this.groupSize;
            }
        }
        return -1;
    }
}
